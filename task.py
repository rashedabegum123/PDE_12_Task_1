# -*- coding: utf-8 -*-
"""TASK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H6rbi8kkU33XyigoZS_n-E82DZV_eURA
"""

import numpy as np
import pandas as pd
from pandas import Series,DataFrame
import math

data = pd.read_csv("/content/sample_data/Rasheda_Begum_Computational_Geometry_for_Park_Design.csv")
data

data.head()
data.columns

# Load a dataset containing the coordinates of the parkâ€™s corners, zones, and key points
#coordinates = data[['Zone_Name', 'Point_A_X', 'Point_A_Y', 'Point_B_X', 'Point_B_Y', 'Shape_Type']]
coordinates = pd.DataFrame(data, columns=['Zone_Name', 'Point_A_X', 'Point_A_Y', 'Point_B_X', 'Point_B_Y', 'Shape_Type'])
coordinates

#Clean the dataset by ensuring all coordinates are valid (no missing values, and proper format)
data.dropna()

df = pd.DataFrame(data)

def calculate_and_display_areas(shape, x1, y1, x2, y2):
    if shape == "Rectangle":
        length = abs(x2 - x1)
        width = abs(y2 - y1)
        return length * width
    elif shape == "triangular":
        print("Triangular shape found.")
    else:
        return None

df["Area"] = df.apply(lambda row: calculate_and_display_areas(row["Shape_Type"], row["Point_A_X"], row["Point_A_Y"], row["Point_B_X"], row["Point_B_Y"]), axis=1)

df_rectangle = df[df["Shape_Type"] == "Rectangle"]
print(df_rectangle[["ID", "Zone_Name", "Area"]])

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))

zone_colors = {
    "Playground": "skyblue",
    "Picnic Area": "lightgreen",
    "Walking Path": "grey",
    "Entrance": "orange",
    "Park Boundary": "brown",
}

for _, row in df.iterrows():
    if row["Shape_Type"] == "Rectangle":
        # Plot rectangles
        plt.fill(
            [row["Point_A_X"], row["Point_B_X"], row["Point_B_X"], row["Point_A_X"]],
            [row["Point_A_Y"], row["Point_A_Y"], row["Point_B_Y"], row["Point_B_Y"]],
            color=zone_colors.get(row["Zone_Name"], "white"),
            alpha=0.5,
            label=row["Zone_Name"] if row["Zone_Name"] not in plt.gca().get_legend_handles_labels()[1] else "",
        )
        # Add labels
        center_x = (row["Point_A_X"] + row["Point_B_X"]) / 2
        center_y = (row["Point_A_Y"] + row["Point_B_Y"]) / 2
        plt.text(center_x, center_y, row["Zone_Name"], fontsize=9, ha="center")

plt.xlabel("X Coordinates")
plt.ylabel("Y Coordinates")
plt.title("Park Layout and Zones")
plt.legend(loc="upper left")
plt.grid(True)
plt.show()

fencing_cost_per_meter = 15  # Adjust this value as needed

def calculate_perimeter(shape, x1, y1, x2, y2):
    if shape == "Rectangle":
        length = abs(x2 - x1)
        width = abs(y2 - y1)
        return 2 * (length + width)
    else:
        return 0


df["Perimeter"] = df.apply(
    lambda row: calculate_perimeter(row["Shape_Type"], row["Point_A_X"], row["Point_A_Y"], row["Point_B_X"], row["Point_B_Y"]),
    axis=1
)

total_fencing = df["Perimeter"].sum()

total_fencing_cost = total_fencing * fencing_cost_per_meter

print(f"Total Fencing Required: {total_fencing:.2f} meters")
print(f"Total Fencing Cost: ${total_fencing_cost:.2f}")

m = 10
b = 50

def calculate_distance(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)


def calculate_path_cost(x1, y1, x2, y2):
    d = calculate_distance(x1, y1, x2, y2)
    return m * d + b


df["Path_Cost"] = df.apply(
    lambda row: calculate_path_cost(row["Point_A_X"], row["Point_A_Y"], row["Point_B_X"], row["Point_B_Y"]),
    axis=1
)

walking_paths_df = df[df["Shape_Type"] == "Linear"]


total_walking_path_cost = walking_paths_df["Path_Cost"].sum()


print(f"Total Walking Path Construction Cost: ${total_walking_path_cost:.2f}")


walking_paths_df.to_csv("walking_path_costs.csv", index=False)
print("Walking path costs saved to 'walking_path_costs.csv'.")